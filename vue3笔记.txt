setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined
<script setup> 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。
==>有点类似于返回了一个render()函数
==>setup是beforeCreate和created的整合

ref中的深层对象，会通过reactive() 转换为响应式代理
对于浅层 ref，只有 .value 的访问会被追踪
==>浅层ref，只有改变.value的指向时才会被追踪

reactive会返回一个最顶层对象的proxy
==>只有最外层属性是proxy，深层的属性没有。但是当访问深层属性时，如果值是一个对象，返回的是一个reactive包装的proxy
==>const proxy = reactive({})
       const raw = {}
       proxy.nested = raw  // false,因为调用 proxy.nested时返回的是一个proxy

console.log(proxy.nested === raw) // false
对同一个对象多次调用reactive(),返回的代理对象为完全等
==>reactive(a)  === reactive(a) :true
==>因为第一次reactive后，会给a对象打上标记，标记值为proxy
如果对象已经被代理过，再次调用返回的是该代理对象

reactive它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)
声明一个变量指向一个reactive的proxy代理，如果改变这个变量的引用，那么将失去对原来proxy的连接
==>let state = reactive({ count: 0 }) // proxy1
       state = reactive({ count: 1 }) //proxy2。 重新赋值后，模板不会更新。
===> let state2 = ref({name:1})
          state2.value = reactive({ name:2 }) // 重新赋值后，模板会更新
==>与ref的.value引用替换不同之处：state是一个变量指向一个proxy，vue无法监测到一个变量的引用的改变。而vue监听的是属性值的改变， state2.value是触发的属性值的改变。

reactive对解构不友好。
对reactive深层属性的解构时，如果值是对象，那么依然会返回一个proxy。

// 当一个对象作为ref的参数时，.value的值和reactive这个对象是等效的。即该对象的ref都会自动解包。
==>
       const a = ref({})
       const b = ref('bbbb')
       a.value.b = b
       console.log(a.value.b) 


当一个ref作为reactive的一个属性时，我们在引用该ref或者设置该ref时，不再需要写.value。
==>因为当把一个ref proxy作为一个响应式的对象的属性时，会自动把该proxy的引用赋值给该属性，但会在作为响应式对象的属性被访问或修改时自动解包
==>也就是说对reactive中的不论是普通属性还是ref的属性，读和写都不用再写.value
==>这些只对深层响应式对象，当其作为浅层响应式对象的属性被访问时不会解包。
==>const count = ref(0)
       const state = reactive({
         count
       })  // 此时count的值不再时一个proxy,但是却有.value属性。虽然有.value,但我们使用时不用写.value
      console.log(state.count) // 引用该ref，虽然count的属性值是一个对象，但此时返回的值时0
      state.count = 1 // 修改该ref

当集合（数组、map）作为reactive对象的属性值时间，如果数组中的元素是ref proxy代理，那么在读和写时依然需要写.value
==>const books = reactive([ref('Vue 3 Guide')]) 
       console.log(books[0].value) // 这里需要 .value
       const books2 = reactive({
          list:[ref('Vue 3 Guide')]
       }) 
       console.log(books2.list[0].value) // 这里也需要 .value

在模板渲染上下文中，只有顶级的 ref 属性才会被解包。
==>如果在模板中使用a.b.c.d这种层级属性时，vue会判断a是否是proxy，如果不是，那么就不会自动解包
===>const count = ref(0)
          const object = { id: ref(1) }
          {{ count + 1 }}  // 会自动解包
          {{ object.id + 1 }} // 不会自动解包，因为{{}}中的最终值不是object.id,且object不是proxy
          {{ object.id }} // 会自动解包，因为{{}}中的最终值是object.id，该特性仅仅是文本插值的一个便利特性，等价于 {{ object.id.value }}
          const { id } = object
          {{ id + 1 }}  // 会自动解包，因为Id是proxy

computed是参数为一个函数或者一个get、set对象
===>返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 .value 访问计算结果,计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value
===>const fullName = computed({
         get() { },
         set(newValue) {}
        })
        调用set时，需要使用.value：fullName.value = ''


当调用 onMounted 时，Vue 会自动将回调函数注册到【当前正被初始化的】组件实例上
onMounted应当在组件初始化时被【同步注册】，即setup执行完后再注册生命周期就无效了
==>setTimeout(() => {
         onMounted(() => {
           // 异步注册时当前组件实例已丢失(即setup执行完当前组件实例丢失)
           // 这将不会正常工作
         })
       }, 100)
注意这并不意味着对 onMounted 的调用必须放在 setup() 或 <script setup> 内的词法上下文中。onMounted() 也可以在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup() 就可以。

watch的第一个参数可以是ref proxy（包括计算属性），可以是一个响应式对象， 可以是()=>{}，可以是数组。
watch的第三个参数{deep,immediate,once:仅触发一次，flush：侦听器回调中能访问被 Vue 更新之后的所属组件的 DOM（也可以直接使用watchPostEffect（）}
不能直接侦听响应式对象的属性值：
==>const obj = reactive({ count: 0 })
       watch(obj.count, (count) => { // 错误，因为 watch() 得到的参数是一个 number,可以使用() => obj.count
         console.log(`count is: ${count}`)
       })
watch的监听对象为一个响应式对象时，会隐式地创建一个深层侦听器，该回调函数在所有嵌套的变更时都会被触发。
相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：
==>watch(
         () => state.someObject,
         () => { // 仅当 state.someObject 被替换时触发
           }
       )


watchEffect() 允许我们自动跟踪回调的响应式依赖：
==>watchEffect(async () => {
           const response = await fetch(
             `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
           )
           data.value = await response.json()
         })
        这个例子中，回调会立即执行，不需要指定 immediate: true

默认情况下，侦听器回调会在父组件更新 (如有) 之后、所属组件的 DOM 更新之前被调用。这意味着如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于更新前的状态。
在setup中可以同步创建监听（会自动销毁）也可以异步创建监听（需要手动销毁）。其它地方创建的监听需要手动销毁。

引用dom元素时，变量名和dom的ref名称必须一致，可以使用const a = ref(null)，也可以使用let a = null
ref attribute 还可以绑定为一个函数,会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数:
==><input :ref="(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }"> // dom注销时也会触发，并且el值为null
使用了 <script setup> 的组件是默认私有的：一个父组件无法访问到一个使用了 <script setup> 的子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露：
==><script setup>
        import { ref } from 'vue'
        const a = 1
        const b = ref(2)
        // 像 defineExpose 这样的编译器宏不需要导入
        defineExpose({
          a,
          b // 父组件通过ref调用b时，会自动解包（因为defineExpose会把所有属性解包，有点像reactive）
        })
</script>

toRef、toRefs用于将reactive内的节点提取出来，同时具有响应式结构：
==>var student = reactive({
        name: '张三',
        age: 15,
        contact: {
            phone: '18714896998',
            qq: '103422412',
            email: 'wm218@qq.com'
        }
       })
       var name = toRef(student, 'name') // toRef用法
      name.value = '李四'  // 修改toRef值的proxy后，student中的name也会跟着变化

===> const student2 = toRefs(student) // student2所有直接子元素属性都会变为ref proxy，但是contract的属性不会变为ref proxy



defineProps 是一个仅 <script setup> 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。defineProps 会返回一个对象，其中包含了可以传递给组件的所有 props。

你也可以使用 is attribute 来创建一般的 HTML 元素。

defineEmits 仅可用于 <script setup> 之中，并且不需要导入，它返回一个等同于 $emit 方法的 emit 函数。
emit校验无论返回true或者false，父组件都会监听到

defineModel主要用于父子组件之间。
defineModel在子组件中声明，在父组件中绑定、传值。
defineModel() 返回的值是一个 ref。它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用：
它的 .value 和父组件的 v-model 的值同步；
当它被子组件变更了，会触发父组件绑定的值一起更新。
===>const model = defineModel({ required: true }) // 使 v-model 必填
===>const model = defineModel({ default: 0 }) // 提供一个默认值

组件上的 v-model 也可以接受一个参数：
<MyComponent v-model:title="bookTitle" />
在子组件中，我们可以通过将【字符串】作为第一个参数传递给 defineModel():或者const title = defineModel('title', { required: true })
===>
     <!-- MyComponent.vue -->
     <script setup>
     const title = defineModel('title')
     </script>

     <template>
       <input type="text" v-model="title" />
     </template>

处理 v-model 修饰符：
===>
       const [model, modifiers] = defineModel() //  modifiers是一个对象
为了能够基于修饰符选择性地调节值的读取和写入方式，我们可以给 defineModel() 传入 get 和 set 这两个选项。这两个选项在从模型引用中读取或设置值时会接收到当前的值，【并且它们都应该返回一个经过处理的新值】。
===>
<script setup>
     const [model, modifiers] = defineModel({
       set(value) {
         if (modifiers.capitalize) {
           return value.charAt(0).toUpperCase() + value.slice(1)
         }
         return value
       }
     })
</script>

当子组件的根元素触发了click事件，那么父组件的@click也会触发。
有些情况下一个组件会在根节点上渲染另一个组件，那么父组件绑定的attribute和事件监听会深层传递。
如果你不想要一个组件自动地继承 attribute，可以使用：
===>
       defineOptions({
         inheritAttrs: false  // 只是让传入的属性不会自动绑定到根元素上，但组件还是能通过$attrs接收到或者使用 import { useAttrs } from 'vue' ；const attrs = useAttrs()。
和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 foo-bar 这样的一个 attribute 需要通过 $attrs['foo-bar'] 来访问。
像 @click 这样的一个 v-on 事件监听器将在此对象下被暴露为一个函数 $attrs.onClick。
当子组件中多个根节点时，传入的属性和事件不会自动绑定，这时必须手动设置$attrs绑定的元素。

动态插槽名：
===>
         <template #[dynamicSlotName]></template>

provide:
===>
        import { provide } from 'vue'
        provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖:
===>
        import { createApp } from 'vue'
        const app = createApp({})
        app.provide(/* 注入名 */ 'message', /* 值 */ 'hello!')

使提供的数据不能被注入方的组件更改：
===>
       import { ref, provide, readonly } from 'vue'
       const count = ref(0)
       provide('read-only-count', readonly(count))

inject:
===>
        import { inject } from 'vue'
        const message = inject('message') 或者 const value = inject('message', '这是默认值') 或者 const value = inject('key', () => new ExpensiveClass(), true)  //  第三个参数表示默认值应该被当作一个工厂函数。

异步组件使用defineAsyncComponent()函数成生一个异步组件，defineAsyncComponent的参数为一个函数，该函数返回一个promise；可以从服务器获取组件，也可以使用import导入组件。
如果是采用import方式，在项目中的source面板中本身不存在对应的组件，只有让组件渲染后，才会从服务器中异步获取该组件。
defineAsyncComponent函数也可以传入一个对象。
异步组件可以搭配内置的 <Suspense> 组件一起使用


组合式函数有点类似于vue2中的mixin，只不过组合式函数可以采用函数的形式进行组合，而mixin多采用导出一个对象格式的形式进行混入。
如果你的组合式函数在输入参数是 ref 或 getter 的情况下创建了响应式 effect，为了让它能够被正确追踪，请确保要么使用 watch() 显式地监视 ref 或 getter，要么在 watchEffect() 中调用 toValue()。
当从组合式函数中返回响应式对象时，toRefs 相当有用。使用它，消费者组件可以解构/展开返回的对象而不会失去响应性：
===>
       function useFeatureX() {
         const state = reactive({
           foo: 1,
           bar: 2
         })
         // 在返回时都转为 ref
         return toRefs(state)
       }
       // 可以解构而不会失去响应性
       const { foo, bar } = useFeatureX()
toRefs 在调用时只会为源对象上可以枚举的属性创建 ref。如果要为可能还不存在的属性创建 ref，请改用 toRef。
如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 reactive() 包装一次，这样其中的 ref 会被自动解包：
===>
       useMouse:
       export default {
           a:ref('')	
       }

       const mouse = reactive(useMouse())
       // mouse.a 链接到了原来的 a ref
       console.log(mouse.a)


组合式函数只能在 <script setup> 或 setup() 钩子中被调用。在这些上下文中，它们也只能被同步调用。在某些情况下，你也可以在像 onMounted() 这样的生命周期钩子中调用它们。
这些限制很重要，因为这些是 Vue 用于确定当前活跃的组件实例的上下文。访问活跃的组件实例很有必要，这样才能：
将生命周期钩子注册到该组件实例上
将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。
<script setup> 是唯一在调用 await 之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前的组件实例。

一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。
===>
       const vFocus = {
         mounted: (el) => el.focus()
       }
在 <script setup> 中，任何以 v 开头的【驼峰式命名的变量】都可以被用作一个自定义指令。vFocus 即可以在模板中以 v-focus 的形式使用。
和内置指令类似，自定义指令的参数也可以是动态的
<div v-example:[arg]="value"></div>
仅仅需要在 mounted 和 updated 上实现相同的行为：
===>
       const vInput = ()=>{
         console.log('1111')
       }


<Suspense> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。
<Suspense> 可以等待的异步依赖有两种：异步 setup()的组件、异步组件。
异步组件默认就是“suspensible”的。这意味着如果组件关系链上有一个 <Suspense>，那么这个异步组件就会被当作这个 <Suspense> 的一个异步依赖。在这种情况下，
加载状态是由 <Suspense> 控制，而该组件自己的加载、报错、延时和超时等选项都将被忽略。异步组件也可以通过在选项中指定 suspensible: false 表明不用 Suspense 控制，并让组件始终自己控制其加载状态。
当Suspense组件的根组件被替换时，如果新的组件也存在异步，则会重新进入挂起状态。
<Suspense> 组件会触发三个事件：pending、resolve 和 fallback
<Suspense> 组件自身目前还不提供错误处理，不过你可以使用 errorCaptured 选项或者 onErrorCaptured() 钩子，在使用到 <Suspense> 的父组件中捕获和处理异步错误。
我们常常会将 <Suspense> 和 <Transition>、<KeepAlive> 等组件结合。要保证这些组件都能正常工作，嵌套的顺序非常重要：
===>
       <RouterView v-slot="{ Component }">
         <template v-if="Component"> // 这个判断非常重要，不然会报错
           <Transition mode="out-in">
             <KeepAlive>
               <Suspense>
                 <!-- 主要内容 -->
                 <component :is="Component"></component>

                 <!-- 加载中状态 -->
                 <template #fallback>
                   正在加载...
                 </template>
               </Suspense>
             </KeepAlive>
           </Transition>
         </template>
       </RouterView>

Vue Router 使用动态导入对懒加载组件进行了内置支持。这些与异步组件不同，目前他们不会触发 <Suspense>。但是，它们仍然可以有异步组件作为后代，这些组件可以照常触发 <Suspense>。
==>也就是说，异步路由不会触发Suspense，但是如果异步路由的组件包含了async setup或者异步组件，那么依然会触发Suspense。