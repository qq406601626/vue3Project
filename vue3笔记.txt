// 在写hooks时需要注意的规范：
// 1、如果返回reactive，解构会失去响应式。
// 2、如果返回toRefs，那么每个属性都需要结构才能用，如果变量多了则不好维护。
// 所以应该返回toRefs,如果返回的属性多了，可以在外层使用reactive，这样里层的ref会自动解包。
// 例如：返回的对象里每个属性都是ref（类似于toRefs）
// 1、使用解构方式：
// "x" and "y" are refs
// const { x, y } = useMouse()
// console.log(x.value)
// const mouse = useMouse()
// console.log(mouse.x.value)
// 2、使用对象方式
// import { reactive } from 'vue'
// const mouse = reactive(useMouse())
// "x" and "y" will be auto unwrapped, no `.value` needed
// console.log(mouse.x)


ref返回的是一个RefImpl类型，内层的非原始值将通过 reactive() 转换为响应式代理。ref.value返回的是一个proxy。
reactive返回的是一个Proxy类型。
reactive() 将深层地转换对象：当访问嵌套对象时，它们也会被 reactive() 包装。即访问reactive对象的属性时，会返回proxy。（并非时在声明时做的，而是在访问时做的proxy处理）
当 ref 的值是一个对象时，ref() 也会在内部调用reactive：即声明一个ref({})，ref.value的值为reactive()的返回值。
一个 ref 会在作为响应式对象的属性被访问或修改时自动解包：
===>
       const obj = ref({
         nested: { count: 0 },
           arr: ['foo', 'bar'],
           user : ref('zhangsan')
         })
         console.log(obj.value.user) // zhangsan。不能写为obj.value.user.value，因为obj.value为proxy响应式对象，访问响应式对象的属性时RefImpl会自动解包。
        // 如果只打印obj，user的值为RefImpl。

在模板中解包的理解：
===>
         const count = ref(0)
         const object = { id: ref(1) }
         {{ count + 1 }} // 会自动解包：判断count变量是RefImpl，则解包。
         {{ object.id + 1 }} // 不会自动解包。判断object变量不是RefImpl，不解包。



watchEffect的第二个参数：
flush: 'post' ，将会使侦听器延迟到组件渲染之后再执行，即在setup执行完了才执行。
flush: 'sync'，修改watchEffect回调中的任何一个变量都会触发一次回调。如果不设置flush: 'sync'，则会在nexttick后调用一次回调。、
onTrack(e) {
    debugger
  },
onTrigger(e) {
    debugger
}
watchEffect的回调函数有一个入参onCleanup函数，该函数需要传入一个函数作为参数。该函数在声明watchEffect时不会执行，只有当再出发出watchEffect时才会执行，并且是优先函数回调执行。
watchEffect返回一个取消监听的函数。
watchEffect中的异步函数中的变量不能触发监听。
watchEffect 仅会在其同步执行期间，才追踪依赖。在使用异步回调时，只有在第一个 await 正常工作前访问到的属性才会被追踪。
setTimeout中的watchEffect会执行，但是需要手动取消监听。watchEffect中的setTimeout不会执行。

watch第一个参数：
一个函数，返回一个值
一个 ref
一个响应式对象
...或是由以上类型的值组成的数组，当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。
watch第二个参数为回调函数，这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数
watch第三个参数：
第三个可选的参数是一个对象，支持以下这些选项：
immediate：在侦听器创建时立即触发回调。第一次调用时旧值是 undefined。
deep：如果源是对象，强制深度遍历，以便在深层级变更时触发回调。参考深层侦听器。
flush：调整回调函数的刷新时机。参考回调的刷新时机及 watchEffect()。
onTrack / onTrigger：调试侦听器的依赖。参考调试侦听器。
once：回调函数只会运行一次。侦听器将在回调函数首次运行后自动停止

当监听的第一个参数为回调函数时，会判断回调函数的返回值是否是绝对相等（即===）
当监听的第一个参数为reactive时，默认为deep模式
当第一个参数为ref时，只有当ref.value发生改变时才会触发监听，除非加上deep。


​readonly():接受一个对象 (不论是响应式还是普通的) 或是一个 ref。只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的 ref 解包行为与 reactive() 相同，但解包得到的值是只读的。
readonly函数是递归的，也就是说，如果一个对象包含其他对象，那么这些对象也会被转换为只读对象

unref:如果参数是 ref，则返回内部值，否则返回参数本身。这是 val = isRef(val) ? val.value : val 计算的一个语法糖

toref:
toRef(existingRef)：会原样返回原来的ref对象
toRef(() => props.foo)：只能读，不能修改
toRef(1)：等同于 ref(1)
const fooRef = toRef(state, 'foo') ：// 双向 ref，会与源属性同步
toref返回的类型为ObjectRefImpl

defineProps的返回值是一个proxy，所以有时候需要使用toRefs(props)之后再解构。
可以对props使用toRef()，但是对props 做出更改的限制依然有效。

toValue()：与 unref() 类似，不同的是此函数也会规范化 getter 函数。如果参数是一个 getter，它将会被调用并且返回它的返回值。

toRefs()：循环【一个响应式对象】的属性，然后对每个属性使用toRef()。当需要解构但不丢失响应式的时候，需要使用toRefs：
1、对props使用toRefs然后解构。
2、当从组合式函数中返回响应式对象时：
function useFeatureX() {
  const state = reactive({
    foo: 1,
    bar: 2
  })
  // 在返回时都转为 ref
  return toRefs(state)
}
const { foo, bar } = useFeatureX() // 可以解构而不会失去响应性

isProxy():检查一个对象是否是由 reactive()、readonly()、shallowReactive() 或 shallowReadonly() 创建的代理

isReactive():检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理。

shallowRef()：只有对 .value 的访问是响应式的，即只有更改.value的值时才会触发响应式（一般用于ref的参数为对象类型时）：
const state = shallowRef({ count: 1 })
// 不会触发更改
state.value.count = 2
// 会触发更改
state.value = { count: 2 }


triggerRef()：参数为一个shallowRef，triggerRef()经常是配合shallowRef()使用的，当shallowRef()的参数为一个对象时，对该对象的属性进行更改时不会触发响应式，这时需要使用triggerRef()。有点类似$set()的功能：
const shallow = shallowRef({
  greet: 'Hello, world'
})
// 触发该副作用第一次应该会打印 "Hello, world"
watchEffect(() => {
  console.log(shallow.value.greet)
})
// 这次变更不应触发副作用，因为这个 ref 是浅层的
shallow.value.greet = 'Hello, universe'
// 打印 "Hello, universe"
triggerRef(shallow)

customRef()：

onErrorCaptured()：注册一个钩子，在捕获了后代组件传递的错误时调用。
错误可以从以下几个来源中捕获：
1、组件渲染
2、事件处理器
3、生命周期钩子
4、setup() 函数
5、侦听器
6、自定义指令钩子
7、过渡钩子
这个钩子带有三个实参：错误对象、触发该错误的组件实例，以及一个说明错误来源类型的信息字符串。
onErrorCaptured()可以捕获所有子组件的错误和当前组件的错误。如果子组件中也声明了onErrorCaptured()并且返回了false，则不能捕获拦截的错误。
errorCaptured()中可以抛出错误，也可以更改组件状态，但不能因为改变组件状态再次导致渲染错误，否则会死循环。
默认情况下，所有的错误都会被发送到应用级的 app.config.errorHandler (前提是这个函数已经定义)，这样这些错误都能在一个统一的地方报告给分析服务。

onRenderTracked() :当组件渲染过程中追踪到响应式依赖时调用，这个钩子仅在开发模式下可用
onRenderTriggered() ：当响应式依赖的变更触发了组件渲染时调用，这个钩子仅在开发模式下可用

provide()：provide() 必须在组件的 setup() 阶段同步调用。
inject()：inject() 必须在组件的 setup() 阶段同步调用。

extends选项：
同 mixins 一样，所有选项 (setup() 除外) 都将使用相关的策略进行合并。
extends不建议用于组合式 API，extends 是为选项式 API 设计的，不会处理 setup() 钩子的合并。
如果你仍然想要通过组合式 API 来“继承”一个组件，可以在继承组件的 setup() 中调用基类组件的 setup()：
import Base from './Base.js'
export default {
  extends: Base,
  setup(props, ctx) {
    return {
      ...Base.setup(props, ctx),
      // 本地绑定
    }
  }
}
extends总结：
1、A extends B，即便A组件中没有template，也不会继承B组件中的template。
2、extends不会继承setup
3、extends相关业务最好使用选项式
4、如果要被继承的组件是setup模式，需要使用 extends: Base, ...Base.setup(props, ctx)。但是这样依然无法继承要被继承的组件的模板内容。

在template下嵌套template，需要给嵌套的template加上v-if="true"

可以对顶层的template和script、style使用src属性：
<template src="./template.html"></template> // 在src的模板中依然可以绑定.vue文件中的变量
<style src="./style.css"></style>
<script src="./script.js"></script>
你也可以从 npm 依赖中导入资源：
<style src="todomvc-app-css/index.css" />

mergeProps()：mergeProps() 支持以下特定 props 参数的处理，将它们合并成一个对象。
class
style
onXxx 事件监听器——多个同名的事件监听器将被合并到一个数组
示例：
import { mergeProps } from 'vue'
const one = {
  class: 'foo',
  onClick: handlerA
}
const two = {
  class: { bar: true },
  onClick: handlerB
}
const merged = mergeProps(one, two)
/**
 {
   class: 'foo bar',
   onClick: [handlerA, handlerB]
 }
 */

 可以通过在app.config.globalProperties上定义一个ref属性，然后在模板中直接使用该属性名：
 app.config.globalProperties.testName = ref('zhangsan')
 <div>testName:{{testName.value}}</div>
 修改全局属性：
 1、使用getCurrentInstance：
 const {proxy:_this} = getCurrentInstance()
 _this.testName.value = 'lisi'
 2、传入testName属性：
const changeTestName = (testName)=>{
  testName.value = 'lisi'
}
changeTestName(testName)
3、直接修改：
<el-button @click="testName.value='lisi'">changeTest</el-button>

vue 中的 getCurrentInstance 方法返回了 ctx 和 proxy，控制台打印 ctx 和 proxy 发现和 vue2.x 中的 this 等同，习惯使用 this 的朋友可以用 proxy 进行替代。


1、SFC中的setup中的ctx的prototype是普通script中的this
2、在 <script setup> 中创建的变量不会作为属性添加到组件实例中，这使得它们无法从选项式 API 中访问。
3、选项式中的render现在无效。如果要动态生成模板，只能使用选项式API然后返回模板Vnode


选项式API：
 setup(props, { attrs, slots, emit, expose }) {  // ctx:{attrs, slots, emit, expose}

 }
 和props不同，attrs和slots的属性都不是响应式的（即不能监听，但在模板中引用时却可以自动变化）。避免解构它们，并始终通过 attrs.x 或 slots.x 的形式使用其中的属性

cssModule:
cssModule是针对css语法的，对于嵌套的写法，可以不用声明scss。使用时需要使用如下方法：
<style module="test" >
.container{
  background: blue;
  padding: 20px;
  .a {
    background: gray;
  }
}
#container{
  background: pink;
}
</style>
<template>
  <div :class="test.container">
    <span :class="test.a">aaaaaa</span>
  </div>
  <div :id="test.container">qqqqqqq</div>
</template>


<template>
  <p :class="$style.red">This should be red</p> // 没有命名空间时，使用$style
</template>
<template>
  <p :class="classes.red">red</p> // 有命名空间时，直接使用命名空间名称
</template>
或者
import { useCssModule } from 'vue'
useCssModule()
// 具名情况下, 返回 <style module="classes"> 的 class
useCssModule('classes')

<style module="classes">
.red {
  color: red;
}
</style>

使用环境变量：它必须按 import.meta.env.BASE_URL 的原样出现（例如 import.meta.env['BASE_URL'] 是无效的）
使用：import.meta.env.BASE_URL

创建环境变量文件：
.env                # 所有情况下都会加载
.env.local          # 所有情况下都会加载，但会被 git 忽略
.env.[mode]         # 只在指定模式下加载
.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略
注意mode是development或者production，而不是dev或者pro。
自带的一些变量：
MODE： {string} 应用运行的模式。
BASE_URL： {string} 部署应用时的基本 URL。他由base 配置项决定。
PROD： {boolean} 应用是否运行在生产环境（使用 NODE_ENV='production' 运行开发服务器或构建应用时使用 NODE_ENV='production' ）。
DEV： {boolean} 应用是否运行在开发环境
SSR： {boolean} 应用是否运行在 server 上
只有以 VITE_ 为前缀的变量才会暴露给经过 vite 处理的代码：
VITE_SOME_KEY=123
console.log(import.meta.env.VITE_SOME_KEY) // "123"
如果想要在环境变量中使用 $ 符号，则必须使用 \ 对其进行转义。
在html模板中使用变量，不用带import.meta.env（注意：只能在.html文件中使用，vue组件中无效）：
Vite 还支持在 HTML 文件中替换环境变量。import.meta.env 中的任何属性都可以通过特殊的 %ENV_NAME% 语法在 HTML 文件中使用：
<h1>Vite is running in %MODE%</h1>
<p>Using data from %VITE_API_URL%</p>

在onMounted中声明onUnmounted也会执行。
但是外层的onUnmounted会先执行：aaaaaaa=>bbbbbbbbbbbbb=>ccccccccccccc
onMounted(()=>{
  console.log('aaaaaaa')
  onUnmounted(()=>{
    console.log('ccccccccccccc')
  })
})
onUnmounted(()=>{
  console.log('bbbbbbbbbbbbbb')
})

根据不同开发环境设置不同的vite config：
export default defineConfig(async ({ command, mode, isSsrBuild, isPreview }) => { // 支持async
  if (command === 'serve') {
    return {
      // dev 独有配置
    }
  } else {
    // command === 'build'
    return {
      // build 独有配置
    }
  }
})
// dev开发环境command的值为serve


在配置中使用环境变量：
环境变量通常可以从 process.env 获得。

注意 Vite 默认是不加载 .env 文件的，因为这些文件需要在执行完 Vite 配置后才能确定加载哪一个，举个例子，root 和 envDir 选项会影响加载行为。
不过当你的确需要时，你可以使用 Vite 导出的 loadEnv 函数来加载指定的 .env 文件。
import { defineConfig, loadEnv } from 'vite'
export default defineConfig(({ command, mode }) => {
  // 根据当前工作目录中的 `mode` 加载 .env 文件
  // 设置第三个参数为 '' 来加载所有环境变量，而不管是否有 `VITE_` 前缀。
  const env = loadEnv(mode, process.cwd(), '')
  return {
    // vite 配置
    define: {
      __APP_ENV__: JSON.stringify(env.APP_ENV),
    },
  }
})

静态资源：
单独一个文件：
使用new URL('@/assets/img/service/advantage/process/icon-1.png',import.meta.url).href
该方式第一个参数可以是相对路径，也可以是路径别名。
该方式只是会获得一个完整的资源url，当模板中引用该路径时，会把该资源打包。有点类似于模板中的require()方式引入资源。

setup()和data()可以同时存在，先执行setup()，然后绑定到原型链上，所以在data()可以访问到setup()返回的数据,所以methods也可以访问到setup()返回的方法。

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

在一个 Vue3 单文件组件 (SFC)中，<script setup> 和 <script> 它们各自最多只能存在一个
<script setup> 这个脚本块将被预处理为组件的 setup() 函数，这意味着它将为每一个(也可以说每一次)组件实例都执行。
<script> 只在组件被首次引入的时候执行一次，其它地方引入或再次实例化都不会再执行。
vue会把script和script setup中的内容合并。


setup() 自身并不含对组件实例的访问权，即在 setup() 中访问 this 会是 undefined
<script setup> 中的顶层的导入、声明的变量和函数可在同一组件的模板中直接使用。你可以理解为模板是在同一作用域内声明的一个 JavaScript 函数——它自然可以访问与它一起声明的所有内容。
==>有点类似于返回了一个render()函数
==>setup是beforeCreate和created的整合

ref中的深层对象，会通过reactive() 转换为响应式代理
对于浅层 ref，只有 .value 的访问会被追踪
==>浅层ref，只有改变.value的指向时才会被追踪

reactive会返回一个最顶层对象的proxy
==>只有最外层属性是proxy，深层的属性没有。但是当访问深层属性时，如果值是一个对象，返回的是一个reactive包装的proxy
==>const proxy = reactive({})
       const raw = {}
       proxy.nested = raw  // false,因为调用 proxy.nested时返回的是一个proxy

console.log(proxy.nested === raw) // false
对同一个对象多次调用reactive(),返回的代理对象为完全等
==>reactive(a)  === reactive(a) :true
==>因为第一次reactive后，会给a对象打上标记，标记值为proxy
如果对象已经被代理过，再次调用返回的是该代理对象

reactive它只能用于对象类型 (对象、数组和如 Map、Set 这样的集合类型)
声明一个变量指向一个reactive的proxy代理，如果改变这个变量的引用，那么将失去对原来proxy的连接
==>let state = reactive({ count: 0 }) // proxy1
       state = reactive({ count: 1 }) //proxy2。 重新赋值后，模板不会更新。
===> let state2 = ref({name:1})
          state2.value = reactive({ name:2 }) // 重新赋值后，模板会更新
==>与ref的.value引用替换不同之处：state是一个变量指向一个proxy，vue无法监测到一个变量的引用的改变。而vue监听的是属性值的改变， state2.value是触发的属性值的改变。

reactive对解构不友好。
对reactive深层属性的解构时，如果值是对象，那么依然会返回一个proxy。

// 当一个对象作为ref的参数时，.value的值和reactive这个对象是等效的。即该对象的ref都会自动解包。
==>
       const a = ref({})
       const b = ref('bbbb')
       a.value.b = b
       console.log(a.value.b)


当一个ref作为reactive的一个属性时，我们在引用该ref或者设置该ref时，不再需要写.value。
==>因为当把一个ref proxy作为一个响应式的对象的属性时，会自动把该proxy的引用赋值给该属性，但会在作为响应式对象的属性被访问或修改时自动解包
==>也就是说对reactive中的不论是普通属性还是ref的属性，读和写都不用再写.value
==>这些只对深层响应式对象，当其作为浅层响应式对象的属性被访问时不会解包。
==>const count = ref(0)
       const state = reactive({
         count
       })  // 此时count的值不再时一个proxy,但是却有.value属性。虽然有.value,但我们使用时不用写.value
      console.log(state.count) // 引用该ref，虽然count的属性值是一个对象，但此时返回的值时0
      state.count = 1 // 修改该ref

当集合（数组、map）作为reactive对象的属性值时间，如果数组中的元素是ref proxy代理，那么在读和写时依然需要写.value
==>const books = reactive([ref('Vue 3 Guide')])
       console.log(books[0].value) // 这里需要 .value
       const books2 = reactive({
          list:[ref('Vue 3 Guide')]
       })
       console.log(books2.list[0].value) // 这里也需要 .value

在模板渲染上下文中，只有顶级的 ref 属性才会被解包。
==>如果在模板中使用a.b.c.d这种层级属性时，vue会判断a是否是proxy，如果不是，那么就不会自动解包
===>const count = ref(0)
          const object = { id: ref(1) }
          {{ count + 1 }}  // 会自动解包
          {{ object.id + 1 }} // 不会自动解包，因为{{}}中的最终值不是object.id,且object不是proxy
          {{ object.id }} // 会自动解包，因为{{}}中的最终值是object.id，该特性仅仅是文本插值的一个便利特性，等价于 {{ object.id.value }}
          const { id } = object
          {{ id + 1 }}  // 会自动解包，因为Id是proxy

computed是参数为一个函数或者一个get、set对象
===>返回值为一个计算属性 ref。和其他一般的 ref 类似，你可以通过 .value 访问计算结果,计算属性 ref 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value
===>const fullName = computed({
         get() { },
         set(newValue) {}
        })
        调用set时，需要使用.value：fullName.value = ''
调试computed：
===>const plusOne = computed(() => count.value + 1, {
       onTrack(e) {
           debugger
         },
         onTrigger(e) {
           debugger
         }
       })


当调用 onMounted 时，Vue 会自动将回调函数注册到【当前正被初始化的】组件实例上
onMounted应当在组件初始化时被【同步注册】，即setup执行完后再注册生命周期就无效了
==>setTimeout(() => {
         onMounted(() => {
           // 异步注册时当前组件实例已丢失(即setup执行完当前组件实例丢失)
           // 这将不会正常工作
         })
       }, 100)
注意这并不意味着对 onMounted 的调用必须放在 setup() 或 <script setup> 内的词法上下文中。onMounted() 也可以在一个外部函数中调用，只要调用栈是同步的，且最终起源自 setup() 就可以。

watch的第一个参数可以是ref proxy（包括计算属性），可以是一个响应式对象， 可以是()=>{}，可以是数组。
watch的第三个参数{deep,immediate,once:仅触发一次，flush：侦听器回调中能访问被 Vue 更新之后的所属组件的 DOM（也可以直接使用watchPostEffect（）}
不能直接侦听响应式对象的属性值：
==>const obj = reactive({ count: 0 })
       watch(obj.count, (count) => { // 错误，因为 watch() 得到的参数是一个 number,可以使用() => obj.count
         console.log(`count is: ${count}`)
       })
watch的监听对象为一个响应式对象时，会隐式地创建一个深层侦听器，该回调函数在所有嵌套的变更时都会被触发。
相比之下，一个返回响应式对象的 getter 函数，只有在返回不同的对象时，才会触发回调：
==>watch(
         () => state.someObject,
         () => { // 仅当 state.someObject 被替换时触发
           }
       )


watchEffect() 允许我们自动跟踪回调的响应式依赖：
==>watchEffect(async () => {
           const response = await fetch(
             `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
           )
           data.value = await response.json()
         })
        这个例子中，回调会立即执行，不需要指定 immediate: true

默认情况下，侦听器回调会在父组件更新 (如有) 之后、所属组件的 DOM 更新之前被调用。这意味着如果你尝试在侦听器回调中访问所属组件的 DOM，那么 DOM 将处于更新前的状态。
在setup中可以同步创建监听（会自动销毁）也可以异步创建监听（需要手动销毁）。其它地方创建的监听需要手动销毁。

引用dom元素时，变量名和dom的ref名称必须一致，可以使用const a = ref(null)，也可以使用let a = null
ref attribute 还可以绑定为一个函数,会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数:
==><input :ref="(el) => { /* 将 el 赋值给一个数据属性或 ref 变量 */ }"> // dom注销时也会触发，并且el值为null
使用了 <script setup> 的组件是默认私有的：一个父组件无法访问到一个使用了 <script setup> 的子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露：
==><script setup>
        import { ref } from 'vue'
        const a = 1
        const b = ref(2)
        // 像 defineExpose 这样的编译器宏不需要导入
        defineExpose({
          a,
          b // 父组件通过ref调用b时，会自动解包（因为defineExpose会把所有属性解包，有点像reactive）
        })
</script>

toRef、toRefs用于将reactive内的节点提取出来，同时具有响应式结构：
==>var student = reactive({
        name: '张三',
        age: 15,
        contact: {
            phone: '18714896998',
            qq: '103422412',
            email: 'wm218@qq.com'
        }
       })
       var name = toRef(student, 'name') // toRef用法
      name.value = '李四'  // 修改toRef值的proxy后，student中的name也会跟着变化

===> const student2 = toRefs(student) // student2所有直接子元素属性都会变为ref proxy，但是contract的属性不会变为ref proxy



defineProps 是一个仅 <script setup> 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。defineProps 会返回一个对象，其中包含了可以传递给组件的所有 props。

你也可以使用 is attribute 来创建一般的 HTML 元素。

defineEmits 仅可用于 <script setup> 之中，并且不需要导入，它返回一个等同于 $emit 方法的 emit 函数。
emit校验无论返回true或者false，父组件都会监听到
emit校验：
===><script setup>
      const emit = defineEmits({
        submit(payload: { email: string, password: string }) {
          // 通过返回值为 `true` 还是为 `false` 来判断验证是否通过
        }
      })
      </script>

defineModel主要用于父子组件之间。
defineModel在子组件中声明，在父组件中绑定、传值。
defineModel() 返回的值是一个 ref。它可以像其他 ref 一样被访问以及修改，不过它能起到在父组件和当前变量之间的双向绑定的作用：
它的 .value 和父组件的 v-model 的值同步；
当它被子组件变更了，会触发父组件绑定的值一起更新。
===>const model = defineModel({ required: true }) // 使 v-model 必填
===>const model = defineModel({ default: 0 }) // 提供一个默认值

组件上的 v-model 也可以接受一个参数：
<MyComponent v-model:title="bookTitle" />
在子组件中，我们可以通过将【字符串】作为第一个参数传递给 defineModel():或者const title = defineModel('title', { required: true })
===>
     <!-- MyComponent.vue -->
     <script setup>
     const title = defineModel('title')
     </script>

     <template>
       <input type="text" v-model="title" />
     </template>

处理 v-model 修饰符：
===>
       const [model, modifiers] = defineModel() //  modifiers是一个对象
为了能够基于修饰符选择性地调节值的读取和写入方式，我们可以给 defineModel() 传入 get 和 set 这两个选项。这两个选项在从模型引用中读取或设置值时会接收到当前的值，【并且它们都应该返回一个经过处理的新值】。
===>
<script setup>
     const [model, modifiers] = defineModel({
       set(value) {
         if (modifiers.capitalize) {
           return value.charAt(0).toUpperCase() + value.slice(1)
         }
         return value
       }
     })
</script>

当子组件的根元素触发了click事件，那么父组件的@click也会触发。
有些情况下一个组件会在根节点上渲染另一个组件，那么父组件绑定的attribute和事件监听会深层传递。
如果你不想要一个组件自动地继承 attribute，可以使用：
===>
       defineOptions({
         inheritAttrs: false  // 只是让传入的属性不会自动绑定到根元素上，但组件还是能通过$attrs接收到或者使用 import { useAttrs } from 'vue' ；const attrs = useAttrs()。
和 props 有所不同，透传 attributes 在 JavaScript 中保留了它们原始的大小写，所以像 foo-bar 这样的一个 attribute 需要通过 $attrs['foo-bar'] 来访问。
像 @click 这样的一个 v-on 事件监听器将在此对象下被暴露为一个函数 $attrs.onClick。
当子组件中多个根节点时，传入的属性和事件不会自动绑定，这时必须手动设置$attrs绑定的元素。

动态插槽名：
===>
         <template #[dynamicSlotName]></template>

provide:
===>
        import { provide } from 'vue'
        provide(/* 注入名 */ 'message', /* 值 */ 'hello!')
除了在一个组件中提供依赖，我们还可以在整个应用层面提供依赖:
===>
        import { createApp } from 'vue'
        const app = createApp({})
        app.provide(/* 注入名 */ 'message', /* 值 */ 'hello!')

使提供的数据不能被注入方的组件更改：
===>
       import { ref, provide, readonly } from 'vue'
       const count = ref(0)
       provide('read-only-count', readonly(count))

inject:
===>
        import { inject } from 'vue'
        const message = inject('message') 或者 const value = inject('message', '这是默认值') 或者 const value = inject('key', () => new ExpensiveClass(), true)  //  第三个参数表示默认值应该被当作一个工厂函数。

异步组件使用defineAsyncComponent()函数成生一个异步组件，defineAsyncComponent的参数为一个函数，该函数返回一个promise；可以从服务器获取组件，也可以使用import导入组件。
如果是采用import方式，在项目中的source面板中本身不存在对应的组件，只有让组件渲染后，才会从服务器中异步获取该组件。
defineAsyncComponent函数也可以传入一个对象。
异步组件可以搭配内置的 <Suspense> 组件一起使用


组合式函数有点类似于vue2中的mixin，只不过组合式函数可以采用函数的形式进行组合，而mixin多采用导出一个对象格式的形式进行混入。
如果你的组合式函数在输入参数是 ref 或 getter 的情况下创建了响应式 effect，为了让它能够被正确追踪，请确保要么使用 watch() 显式地监视 ref 或 getter，要么在 watchEffect() 中调用 toValue()。
当从组合式函数中返回响应式对象时，toRefs 相当有用。使用它，消费者组件可以解构/展开返回的对象而不会失去响应性：
===>
       function useFeatureX() {
         const state = reactive({
           foo: 1,
           bar: 2
         })
         // 在返回时都转为 ref
         return toRefs(state)
       }
       // 可以解构而不会失去响应性
       const { foo, bar } = useFeatureX()
toRefs 在调用时只会为源对象上可以枚举的属性创建 ref。如果要为可能还不存在的属性创建 ref，请改用 toRef。
如果你更希望以对象属性的形式来使用组合式函数中返回的状态，你可以将返回的对象用 reactive() 包装一次，这样其中的 ref 会被自动解包：
===>
       useMouse:
       export default {
           a:ref('')
       }

       const mouse = reactive(useMouse())
       // mouse.a 链接到了原来的 a ref
       console.log(mouse.a)


组合式函数只能在 <script setup> 或 setup() 钩子中被调用。在这些上下文中，它们也只能被同步调用。在某些情况下，你也可以在像 onMounted() 这样的生命周期钩子中调用它们。
这些限制很重要，因为这些是 Vue 用于确定当前活跃的组件实例的上下文。访问活跃的组件实例很有必要，这样才能：
将生命周期钩子注册到该组件实例上
将计算属性和监听器注册到该组件实例上，以便在该组件被卸载时停止监听，避免内存泄漏。
<script setup> 是唯一在调用 await 之后仍可调用组合式函数的地方。编译器会在异步操作之后自动为你恢复当前的组件实例。

一个自定义指令由一个包含类似组件生命周期钩子的对象来定义。
===>
       const vFocus = {
         mounted: (el) => el.focus()
       }
在 <script setup> 中，任何以 v 开头的【驼峰式命名的变量】都可以被用作一个自定义指令。vFocus 即可以在模板中以 v-focus 的形式使用。
和内置指令类似，自定义指令的参数也可以是动态的
<div v-example:[arg]="value"></div>
仅仅需要在 mounted 和 updated 上实现相同的行为：
===>
       const vInput = ()=>{
         console.log('1111')
       }


<Suspense> 是一个内置组件，用来在组件树中协调对异步依赖的处理。它让我们可以在组件树上层等待下层的多个嵌套异步依赖项解析完成，并可以在等待时渲染一个加载状态。
<Suspense> 可以等待的异步依赖有两种：异步 setup()的组件、异步组件。
异步组件默认就是“suspensible”的。这意味着如果组件关系链上有一个 <Suspense>，那么这个异步组件就会被当作这个 <Suspense> 的一个异步依赖。在这种情况下，
加载状态是由 <Suspense> 控制，而该组件自己的加载、报错、延时和超时等选项都将被忽略。异步组件也可以通过在选项中指定 suspensible: false 表明不用 Suspense 控制，并让组件始终自己控制其加载状态。
当Suspense组件的根组件被替换时，如果新的组件也存在异步，则会重新进入挂起状态。
<Suspense> 组件会触发三个事件：pending、resolve 和 fallback
<Suspense> 组件自身目前还不提供错误处理，不过你可以使用 errorCaptured 选项或者 onErrorCaptured() 钩子，在使用到 <Suspense> 的父组件中捕获和处理异步错误。
我们常常会将 <Suspense> 和 <Transition>、<KeepAlive> 等组件结合。要保证这些组件都能正常工作，嵌套的顺序非常重要：
===>
       <RouterView v-slot="{ Component }">
         <template v-if="Component"> // 这个判断非常重要，不然会报错
           <Transition mode="out-in">
             <KeepAlive>
               <Suspense>
                 <!-- 主要内容 -->
                 <component :is="Component"></component>

                 <!-- 加载中状态 -->
                 <template #fallback>
                   正在加载...
                 </template>
               </Suspense>
             </KeepAlive>
           </Transition>
         </template>
       </RouterView>

Vue Router 使用动态导入对懒加载组件进行了内置支持。这些与异步组件不同，目前他们不会触发 <Suspense>。但是，它们仍然可以有异步组件作为后代，这些组件可以照常触发 <Suspense>。
==>也就是说，异步路由不会触发Suspense，但是如果异步路由的组件包含了async setup或者异步组件，那么依然会触发Suspense。


useSlots() 和 useAttrs()​
在 <script setup> 使用 slots 和 attrs 的情况应该是相对来说较为罕见的，因为可以在模板中直接通过 $slots 和 $attrs 来访问它们。在你的确需要使用它们的罕见场景中，可以分别用 useSlots 和 useAttrs 两个辅助函数：
<script setup>
import { useSlots, useAttrs } from 'vue'
const slots = useSlots()
const attrs = useAttrs()
</script>
useSlots 和 useAttrs 是真实的运行时函数，它的返回与 setupContext.slots 和 setupContext.attrs 等价。它们同样也能在普通的组合式 API 中使用。


深度选择器：
===><style scoped>
       .a :deep(.b) {
         /* ... */
       }
       </style>
上面的代码会被编译成：
       .a[data-v-f3f3eg9] .b {
         /* ... */
       }

插槽选择器：
默认情况下，作用域样式不会影响到 <slot/> 渲染出来的内容，因为它们被认为是父组件所持有并传递进来的。使用 :slotted 伪类以明确地将插槽内容作为选择器的目标：默认为父组件的样式，然后根据权重去判断样式。
===><style scoped>
       :slotted(div) {
         color: red;
       }
       </style>

全局选择器：
<style scoped>
===>:global(.red) {
         color: red;
       }
</style>
对于一个使用了 .a .b 选择器的样式规则来说，如果匹配到 .a 的元素包含了一个递归的子组件，那么所有的在那个子组件中的 .b 都会匹配到这条样式规则。


一个 <style module> 标签会被编译为 CSS Modules 并且将生成的 CSS class 作为 $style 对象暴露给组件：
===>
         <template>
           <p :class="$style.red">This should be red</p>
         </template>
         <style module>
         .red {
           color: red;
         }
         </style>
你可以通过给 module attribute 一个值来自定义注入 class 对象的属性名：
===>
          <template>
            <p :class="classes.red">red</p>
          </template>

          <style module="classes">
          .red {
            color: red;
          }
          </style>

可以通过 useCssModule API 在 setup() 和 <script setup> 中访问注入的 class。对于使用了自定义注入名称的 <style module> 块，useCssModule 接收一个匹配的 module attribute 值作为第一个参数：
===>
          import { useCssModule } from 'vue'
          // 在 setup() 作用域中...
          // 默认情况下, 返回 <style module> 的 class
          useCssModule()
          // 具名情况下, 返回 <style module="classes"> 的 class
          useCssModule('classes')

CSS 中的 v-bind()：会随着变量的变化而更改样式
===>
          <script setup>
          const theme = {
            color: 'red'
          }
          </script>
          <template>
            <p>hello</p>
          </template>
          <style scoped>
          p {
            color: v-bind('theme.color');
          }
          </style>
