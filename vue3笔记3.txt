vue的组件可以是一个函数，即函数式组件：

函数式组件：
Component类型：
Component:ConcreteComponent | ComponentPublicInstanceConstructor。
ConcreteComponent:ComponentOptions | FunctionalComponent。

function MyComponent(props, { slots, emit, attrs }) {
  // ...
}

MyComponent.props = ['value']
MyComponent.emits = ['click']

eg：

function FComponent(
  props: FComponentProps,
  context: SetupContext<Events>
) {
  return (
  jsx:
    <button onClick={() => context.emit('sendMessage', props.message)}>
        {props.message} {' '}
    </button>
  或者:
    h('button',props.message)
  )
}

FComponent.props = {
  message: {
    type: String,
    required: true
  }
}

FComponent.emits = {
  sendMessage: (value: unknown) => typeof value === 'string'
}

在模板渲染上下文中，只有顶级的 ref 属性才会被解包：

在下面的例子中，count 和 object 是顶级属性，但 object.id 不是：
const count = ref(0)
const object = { id: ref(1) }

{{ count + 1 }} // 正常显示

{{ object.id }} // 正常显示

{{ object.id + 1 }} // 渲染的结果将是 [object Object]1，因为在计算表达式时 object.id 没有被解包，仍然是一个 ref 对象。

总结：在模板中，如果不涉及到计算，那么非顶层ref的属性可以正常渲染，如果涉及到计算，那么就会使用到类似setup中的函数一样，这时需要使用.value来解包。

为了解决这个问题，我们可以将 id 解构为一个顶级属性：
const { id } = object
{{ id + 1 }}
